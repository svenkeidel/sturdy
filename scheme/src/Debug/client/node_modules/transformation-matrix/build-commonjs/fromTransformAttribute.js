'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromTransformAttribute = fromTransformAttribute;

var _fromTransformAttribute = require('./fromTransformAttribute.autogenerated');

var _translate = require('./translate');

var _rotate = require('./rotate');

var _fromObject = require('./fromObject');

var _scale = require('./scale');

var _skew = require('./skew');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * Parser for SVG Trasform Attribute http://www.w3.org/TR/SVG/coords.html#TransformAttribute <br/>
 * Warning: This should be considered BETA until it is released a stable version of pegjs.
 * @param transformString string
 * @returns {{descriptors: *, matrices: *}} Parsed matrices
 */
function fromTransformAttribute(transformString) {
  var descriptors = (0, _fromTransformAttribute.parse)(transformString);
  var matrices = descriptors.map(convertMatrixDescriptorToMatrix);
  return { descriptors: descriptors, matrices: matrices };
}

function convertMatrixDescriptorToMatrix(matrixDescriptor) {
  var hasParam = function hasParam(key) {
    return matrixDescriptor.hasOwnProperty(key);
  };

  var type = matrixDescriptor.type,
      params = _objectWithoutProperties(matrixDescriptor, ['type']);

  switch (type) {
    case 'matrix':
      return (0, _fromObject.fromObject)(params);

    case 'translate':
      if (hasParam('ty')) {
        return (0, _translate.translate)(params.tx, params.ty);
      }

      return (0, _translate.translate)(params.tx);

    case 'scale':
      if (hasParam('sy')) {
        return (0, _scale.scale)(params.sx, params.sy);
      }

      return (0, _scale.scale)(params.sx);

    case 'rotate':
      if (hasParam('cx') && hasParam('cy')) {
        return (0, _rotate.rotateDEG)(params.angle, params.cx, params.cy);
      }

      return (0, _rotate.rotateDEG)(params.angle);

    case 'skewX':
      return (0, _skew.skewDEG)(params.angle, 0);

    case 'skewY':
      return (0, _skew.skewDEG)(0, params.angle);

    default:
      /* istanbul ignore next */
      throw new Error('Unsupported descriptor');
  }
}