{"version":3,"file":"autocomplete-trigger.d.ts","sources":["autocomplete-trigger.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directionality } from '@angular/cdk/bidi';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { Overlay, ScrollStrategy } from '@angular/cdk/overlay';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { AfterViewInit, ChangeDetectorRef, ElementRef, InjectionToken, NgZone, OnDestroy, ViewContainerRef, OnChanges, SimpleChanges } from '@angular/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { MatOption, MatOptionSelectionChange } from '@angular/material/core';\nimport { MatFormField } from '@angular/material/form-field';\nimport { Observable } from 'rxjs';\nimport { MatAutocomplete } from './autocomplete';\nimport { MatAutocompleteOrigin } from './autocomplete-origin';\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n/** The height of each autocomplete option. */\nexport declare const AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/** The total height of the autocomplete panel. */\nexport declare const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n/** @docs-private */\nexport declare function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n/** @docs-private */\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport declare const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any;\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport declare function getMatAutocompleteMissingPanelError(): Error;\nexport declare class MatAutocompleteTrigger implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy {\n    private _element;\n    private _overlay;\n    private _viewContainerRef;\n    private _zone;\n    private _changeDetectorRef;\n    private _dir;\n    private _formField;\n    private _document;\n    private _viewportRuler;\n    private _overlayRef;\n    private _portal;\n    private _componentDestroyed;\n    private _autocompleteDisabled;\n    private _scrollStrategy;\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private _previousValue;\n    /** Strategy that is used to position the panel. */\n    private _positionStrategy;\n    /** Whether or not the label state is being overridden. */\n    private _manuallyFloatingLabel;\n    /** The subscription for closing actions (some are bound to document). */\n    private _closingActionsSubscription;\n    /** Subscription to viewport size changes. */\n    private _viewportSubscription;\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private _canOpenOnNextFocus;\n    /** Whether the element is inside of a ShadowRoot component. */\n    private _isInsideShadowRoot;\n    /** Stream of keyboard events that can close the panel. */\n    private readonly _closeKeyEventStream;\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private _windowBlurHandler;\n    /** `View -> model callback called when value changes` */\n    _onChange: (value: any) => void;\n    /** `View -> model callback called when autocomplete has been touched` */\n    _onTouched: () => void;\n    /** The autocomplete panel to be attached to this trigger. */\n    autocomplete: MatAutocomplete;\n    /**\n     * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n     * will render the panel underneath the trigger if there is enough space for it to fit in\n     * the viewport, otherwise the panel will be shown above it. If the position is set to\n     * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n     * whether it fits completely in the viewport.\n     */\n    position: 'auto' | 'above' | 'below';\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    connectedTo: MatAutocompleteOrigin;\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    autocompleteAttribute: string;\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    get autocompleteDisabled(): boolean;\n    set autocompleteDisabled(value: boolean);\n    constructor(_element: ElementRef<HTMLInputElement>, _overlay: Overlay, _viewContainerRef: ViewContainerRef, _zone: NgZone, _changeDetectorRef: ChangeDetectorRef, scrollStrategy: any, _dir: Directionality, _formField: MatFormField, _document: any, _viewportRuler: ViewportRuler);\n    ngAfterViewInit(): void;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    /** Whether or not the autocomplete panel is open. */\n    get panelOpen(): boolean;\n    private _overlayAttached;\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void;\n    /** Closes the autocomplete suggestion panel. */\n    closePanel(): void;\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void;\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<MatOptionSelectionChange | null>;\n    /** Stream of autocomplete option selections. */\n    readonly optionSelections: Observable<MatOptionSelectionChange>;\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): MatOption | null;\n    /** Stream of clicks outside of the autocomplete panel. */\n    private _getOutsideClickStream;\n    writeValue(value: any): void;\n    registerOnChange(fn: (value: any) => {}): void;\n    registerOnTouched(fn: () => {}): void;\n    setDisabledState(isDisabled: boolean): void;\n    _handleKeydown(event: KeyboardEvent): void;\n    _handleInput(event: KeyboardEvent): void;\n    _handleFocus(): void;\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @param shouldAnimate Whether the label should be animated when it is floated.\n     */\n    private _floatLabel;\n    /** If the label has been manually elevated, return it to its normal state. */\n    private _resetLabel;\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private _scrollToOption;\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private _subscribeToClosingActions;\n    /** Destroys the autocomplete suggestion panel. */\n    private _destroyPanel;\n    private _setTriggerValue;\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private _setValueAndClose;\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    private _clearPreviousSelectedOption;\n    private _attachOverlay;\n    private _getOverlayConfig;\n    private _getOverlayPosition;\n    /** Sets the positions on a position strategy based on the directive's input state. */\n    private _setStrategyPositions;\n    private _getConnectedElement;\n    private _getPanelWidth;\n    /** Returns the width of the input element, so the panel width can match it. */\n    private _getHostWidth;\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private _resetActiveItem;\n    /** Determines whether the panel can be opened. */\n    private _canOpen;\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    private _getWindow;\n    static ngAcceptInputType_autocompleteDisabled: BooleanInput;\n}\n"]}