"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllChanges = exports.getChangesForTarget = void 0;
const target_version_1 = require("./target-version");
/**
 * Gets the changes for a given target version from the specified version changes object.
 *
 * For readability and a good overview of breaking changes, the version change data always
 * includes the related Pull Request link. Since this data is not needed when performing the
 * upgrade, this unused data can be removed and the changes data can be flattened into an
 * easy iterable array.
 */
function getChangesForTarget(target, data) {
    if (!data) {
        throw new Error(`No data could be found for target version: ${target_version_1.TargetVersion[target]}`);
    }
    if (!data[target]) {
        return [];
    }
    return data[target].reduce((result, prData) => result.concat(prData.changes), []);
}
exports.getChangesForTarget = getChangesForTarget;
/**
 * Gets all changes from the specified version changes object. This is helpful in case a migration
 * rule does not distinguish data based on the target version, but for readability the
 * upgrade data is separated for each target version.
 */
function getAllChanges(data) {
    return Object.keys(data)
        .map(targetVersion => getChangesForTarget(targetVersion, data))
        .reduce((result, versionData) => result.concat(versionData), []);
}
exports.getAllChanges = getAllChanges;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi1jaGFuZ2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2Nkay9zY2hlbWF0aWNzL3VwZGF0ZS10b29sL3ZlcnNpb24tY2hhbmdlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOzs7QUFFSCxxREFBK0M7QUFhL0M7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLG1CQUFtQixDQUFJLE1BQXFCLEVBQUUsSUFBdUI7SUFDbkYsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE1BQU0sSUFBSSxLQUFLLENBQ1gsOENBQThDLDhCQUFhLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzVFO0lBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNqQixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBUyxDQUFDLENBQUM7QUFDNUYsQ0FBQztBQVhELGtEQVdDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLGFBQWEsQ0FBSSxJQUF1QjtJQUN0RCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ25CLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLGFBQThCLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDL0UsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN2RSxDQUFDO0FBSkQsc0NBSUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtUYXJnZXRWZXJzaW9ufSBmcm9tICcuL3RhcmdldC12ZXJzaW9uJztcblxuZXhwb3J0IHR5cGUgVmVyc2lvbkNoYW5nZXM8VD4gPSB7XG4gIFt0YXJnZXQgaW4gVGFyZ2V0VmVyc2lvbl0/OiBSZWFkYWJsZUNoYW5nZTxUPltdO1xufTtcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVDaGFuZ2U8VD4gPSB7XG4gIHByOiBzdHJpbmc7IGNoYW5nZXM6IFRbXVxufTtcblxuLyoqIENvbmRpdGlvbmFsIHR5cGUgdGhhdCB1bndyYXBzIHRoZSB2YWx1ZSBvZiBhIHZlcnNpb24gY2hhbmdlcyB0eXBlLiAqL1xuZXhwb3J0IHR5cGUgVmFsdWVPZkNoYW5nZXM8VD4gPSBUIGV4dGVuZHMgVmVyc2lvbkNoYW5nZXM8aW5mZXIgWD4/IFggOiBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGNoYW5nZXMgZm9yIGEgZ2l2ZW4gdGFyZ2V0IHZlcnNpb24gZnJvbSB0aGUgc3BlY2lmaWVkIHZlcnNpb24gY2hhbmdlcyBvYmplY3QuXG4gKlxuICogRm9yIHJlYWRhYmlsaXR5IGFuZCBhIGdvb2Qgb3ZlcnZpZXcgb2YgYnJlYWtpbmcgY2hhbmdlcywgdGhlIHZlcnNpb24gY2hhbmdlIGRhdGEgYWx3YXlzXG4gKiBpbmNsdWRlcyB0aGUgcmVsYXRlZCBQdWxsIFJlcXVlc3QgbGluay4gU2luY2UgdGhpcyBkYXRhIGlzIG5vdCBuZWVkZWQgd2hlbiBwZXJmb3JtaW5nIHRoZVxuICogdXBncmFkZSwgdGhpcyB1bnVzZWQgZGF0YSBjYW4gYmUgcmVtb3ZlZCBhbmQgdGhlIGNoYW5nZXMgZGF0YSBjYW4gYmUgZmxhdHRlbmVkIGludG8gYW5cbiAqIGVhc3kgaXRlcmFibGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFuZ2VzRm9yVGFyZ2V0PFQ+KHRhcmdldDogVGFyZ2V0VmVyc2lvbiwgZGF0YTogVmVyc2lvbkNoYW5nZXM8VD4pOiBUW10ge1xuICBpZiAoIWRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBkYXRhIGNvdWxkIGJlIGZvdW5kIGZvciB0YXJnZXQgdmVyc2lvbjogJHtUYXJnZXRWZXJzaW9uW3RhcmdldF19YCk7XG4gIH1cblxuICBpZiAoIWRhdGFbdGFyZ2V0XSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBkYXRhW3RhcmdldF0hLnJlZHVjZSgocmVzdWx0LCBwckRhdGEpID0+IHJlc3VsdC5jb25jYXQocHJEYXRhLmNoYW5nZXMpLCBbXSBhcyBUW10pO1xufVxuXG4vKipcbiAqIEdldHMgYWxsIGNoYW5nZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHZlcnNpb24gY2hhbmdlcyBvYmplY3QuIFRoaXMgaXMgaGVscGZ1bCBpbiBjYXNlIGEgbWlncmF0aW9uXG4gKiBydWxlIGRvZXMgbm90IGRpc3Rpbmd1aXNoIGRhdGEgYmFzZWQgb24gdGhlIHRhcmdldCB2ZXJzaW9uLCBidXQgZm9yIHJlYWRhYmlsaXR5IHRoZVxuICogdXBncmFkZSBkYXRhIGlzIHNlcGFyYXRlZCBmb3IgZWFjaCB0YXJnZXQgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENoYW5nZXM8VD4oZGF0YTogVmVyc2lvbkNoYW5nZXM8VD4pOiBUW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgIC5tYXAodGFyZ2V0VmVyc2lvbiA9PiBnZXRDaGFuZ2VzRm9yVGFyZ2V0KHRhcmdldFZlcnNpb24gYXMgVGFyZ2V0VmVyc2lvbiwgZGF0YSkpXG4gICAgICAucmVkdWNlKChyZXN1bHQsIHZlcnNpb25EYXRhKSA9PiByZXN1bHQuY29uY2F0KHZlcnNpb25EYXRhKSwgW10pO1xufVxuIl19